{"code":"import { lYearDays, leapMonth, leapDays, monthDays, toGanZhiYear, toGanZhi, toChinaMonth, toChinaDay } from \"../utils/LunarFunction\";\nimport { toAstro, getTerm, getAnimal } from \"../utils/SolarFunction\";\nimport { Rest, Festival } from \"../data/Days\";\nimport { nStr1, SolarTerm } from \"../data/Calendar\";\nconst solar2lunar = (y, m, d) => {\n    //未传参  获得当天\n    let objDate;\n    if (!y) {\n        objDate = new Date();\n    }\n    else {\n        objDate = new Date(y, m - 1, d);\n    }\n    let i, leap = 0, temp = 0;\n    //修正ymd参数\n    y = objDate.getFullYear(),\n        m = objDate.getMonth() + 1,\n        d = objDate.getDate();\n    let offset = (Date.UTC(objDate.getFullYear(), objDate.getMonth(), objDate.getDate()) - Date.UTC(1900, 0, 31)) / 86400000;\n    for (i = 1900; i < 2101 && offset > 0; i++) {\n        temp = lYearDays(i);\n        offset -= temp;\n    }\n    if (offset < 0) {\n        offset += temp;\n        i--;\n    }\n    //是否今天\n    let isTodayObj = new Date(), isToday = false;\n    if (isTodayObj.getFullYear() == y && isTodayObj.getMonth() + 1 == m && isTodayObj.getDate() == d) {\n        isToday = true;\n    }\n    //星期几\n    var nWeek = objDate.getDay(), cWeek = nStr1[nWeek];\n    //数字表示周几顺应天朝周一开始的惯例\n    if (nWeek == 0) {\n        nWeek = 7;\n    }\n    //农历年\n    let year = i;\n    leap = leapMonth(i); //闰哪个月\n    let isLeap = false;\n    //效验闰月\n    for (i = 1; i < 13 && offset > 0; i++) {\n        //闰月\n        if (leap > 0 && i == (leap + 1) && isLeap == false) {\n            --i;\n            isLeap = true;\n            temp = leapDays(year); //计算农历闰月天数\n        }\n        else {\n            temp = monthDays(year, i); //计算农历普通月天数\n        }\n        //解除闰月\n        if (isLeap == true && i == (leap + 1)) {\n            isLeap = false;\n        }\n        offset -= temp;\n    }\n    // 闰月导致数组下标重叠取反\n    if (offset == 0 && leap > 0 && i == leap + 1) {\n        if (isLeap) {\n            isLeap = false;\n        }\n        else {\n            isLeap = true;\n            --i;\n        }\n    }\n    if (offset < 0) {\n        offset += temp;\n        --i;\n    }\n    //农历月\n    let month = i;\n    //农历日\n    let day = offset + 1;\n    //天干地支处理\n    let sm = m - 1;\n    let gzY = toGanZhiYear(year);\n    // 当月的两个节气\n    // bugfix-2017-7-24 11:03:38 use lunar Year Param `y` Not `year`\n    let firstNode = getTerm(y, (m * 2 - 1)); //返回当月「节」为几日开始\n    let secondNode = getTerm(y, (m * 2)); //返回当月「节」为几日开始\n    // 依据12节气修正干支月\n    let gzM = toGanZhi((y - 1900) * 12 + m + 11);\n    if (d >= firstNode) {\n        gzM = toGanZhi((y - 1900) * 12 + m + 12);\n    }\n    //传入的日期的节气与否\n    let isTerm = false;\n    let Term = null;\n    if (firstNode == d) {\n        isTerm = true;\n        Term = SolarTerm[m * 2 - 2];\n    }\n    if (secondNode == d) {\n        isTerm = true;\n        Term = SolarTerm[m * 2 - 1];\n    }\n    //日柱 当月一日与 1900/1/1 相差天数\n    let dayCyclical = Date.UTC(y, sm, 1, 0, 0, 0, 0) / 86400000 + 25567 + 10;\n    let gzD = toGanZhi(dayCyclical + d - 1);\n    //该日期所属的星座\n    let astro = toAstro(m, d);\n    // 设置公里节日（后期改为npm）\n    let sFtvSelect = (m < 10 ? \"0\" + m : m.toString()) + (d < 10 ? \"0\" + d : d.toString());\n    let lFtvSelect = (month < 10 ? \"0\" + month : month.toString()) + (day < 10 ? \"0\" + day : day.toString());\n    let Gljr = \"\", Nljr = \"\";\n    if (Festival.sFtv[sFtvSelect])\n        Gljr = Festival.sFtv[sFtvSelect];\n    if (Festival.lFtv[lFtvSelect])\n        Nljr = Festival.lFtv[lFtvSelect];\n    // 设置法定节假日\n    let Xiu = false, Ban = false;\n    let XiuBox = Rest[y];\n    Xiu = XiuBox.xiu.includes(sFtvSelect);\n    Ban = XiuBox.ban.includes(sFtvSelect);\n    // 用于设置上个月\n    let DayInfo = { \"Xiu\": Xiu, \"Ban\": Ban, \"Gljr\": Gljr, \"Nljr\": Nljr, 'lYear': year, 'lMonth': month, 'lDay': day, 'Animal': getAnimal(year), 'IMonthCn': (isLeap ? \"\\u95f0\" : '') + toChinaMonth(month), 'IDayCn': toChinaDay(day), 'cYear': y, 'cMonth': m, 'cDay': d, 'gzYear': gzY, 'gzMonth': gzM, 'gzDay': gzD, 'isToday': isToday, 'isLeap': isLeap, 'nWeek': nWeek, 'ncWeek': \"\\u661f\\u671f\" + cWeek, 'isTerm': isTerm, 'Term': Term, 'astro': astro };\n    return DayInfo;\n};\nconst lunar2solar = (y, m, d, isLeapMonth) => {\n    isLeapMonth = !!isLeapMonth;\n    let leapM = leapMonth(y);\n    if (isLeapMonth && (leapM != m)) {\n        return -1;\n    } //传参要求计算该闰月公历 但该年得出的闰月与传参的月份并不同\n    if (y == 2100 && m == 12 && d > 1 || y == 1900 && m == 1 && d < 31) {\n        return -1;\n    } //超出了最大极限值 \n    let day = monthDays(y, m);\n    let _day = day;\n    //bugFix 2016-9-25 \n    //if month is leap, _day use leapDays method \n    if (isLeapMonth) {\n        _day = leapDays(y);\n    }\n    if (y < 1900 || y > 2100 || d > _day) {\n        return -1;\n    } //参数合法性效验\n    //计算农历的时间差\n    let offset = 0;\n    for (let i = 1900; i < y; i++) {\n        offset += lYearDays(i);\n    }\n    let leap = 0, isAdd = false;\n    for (let i = 1; i < m; i++) {\n        leap = leapMonth(y);\n        if (!isAdd) { //处理闰月\n            if (leap <= i && leap > 0) {\n                offset += leapDays(y);\n                isAdd = true;\n            }\n        }\n        offset += monthDays(y, i);\n    }\n    //转换闰月农历 需补充该年闰月的前一个月的时差\n    if (isLeapMonth) {\n        offset += day;\n    }\n    //1900年农历正月一日的公历时间为1900年1月30日0时0分0秒(该时间也是本农历的最开始起始点)\n    let stmap = Date.UTC(1900, 1, 30, 0, 0, 0);\n    let calObj = new Date((offset + d - 31) * 86400000 + stmap);\n    let cY = calObj.getUTCFullYear();\n    let cM = calObj.getUTCMonth() + 1;\n    let cD = calObj.getUTCDate();\n    return solar2lunar(cY, cM, cD);\n};\nexport { solar2lunar, lunar2solar };\n","references":["D:/Web/npm/yz-calendar-ts/src/utils/LunarFunction.ts","D:/Web/npm/yz-calendar-ts/src/utils/SolarFunction.ts","D:/Web/npm/yz-calendar-ts/src/data/Days.ts","D:/Web/npm/yz-calendar-ts/src/data/Calendar.ts"]}
